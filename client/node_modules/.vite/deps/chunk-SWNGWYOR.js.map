{
  "version": 3,
  "sources": ["../../void-elements/index.js", "../../html-parse-stringify/src/parse-tag.js", "../../html-parse-stringify/src/parse.js", "../../html-parse-stringify/src/stringify.js", "../../html-parse-stringify/src/index.js"],
  "sourcesContent": ["/**\n * This file automatically generated from `pre-publish.js`.\n * Do not manually edit.\n */\n\nmodule.exports = {\n  \"area\": true,\n  \"base\": true,\n  \"br\": true,\n  \"col\": true,\n  \"embed\": true,\n  \"hr\": true,\n  \"img\": true,\n  \"input\": true,\n  \"link\": true,\n  \"meta\": true,\n  \"param\": true,\n  \"source\": true,\n  \"track\": true,\n  \"wbr\": true\n};\n", "import lookup from 'void-elements'\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nexport default function stringify(tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: {},\n    children: [],\n  }\n\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n  if (tagMatch) {\n    res.name = tagMatch[1]\n    if (\n      lookup[tagMatch[1]] ||\n      tag.charAt(tag.length - 2) === '/'\n    ) {\n      res.voidElement = true\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->')\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\n      }\n    }\n  }\n\n  const reg = new RegExp(attrRE)\n  let result = null\n  for (;;) {\n    result = reg.exec(tag)\n\n    if (result === null) {\n      break\n    }\n\n    if (!result[0].trim()) {\n      continue\n    }\n\n    if (result[1]) {\n      const attr = result[1].trim()\n      let arr = [attr, '']\n\n      if (attr.indexOf('=') > -1) {\n        arr = attr.split('=')\n      }\n\n      res.attrs[arr[0]] = arr[1]\n      reg.lastIndex--\n    } else if (result[2]) {\n      res.attrs[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n    }\n  }\n\n  return res\n}\n", "import parseTag from './parse-tag'\n\nconst tagRE = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g\nconst whitespaceRE = /^\\s*$/\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n        // move current up a level to match the end tag\n        current = level === -1 ? result : arr[level]\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        let content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, collapse it as the spec states:\n        // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n        if (whitespaceRE.test(content)) {\n          content = ' '\n        }\n        // don't add whitespace-only text nodes if they would be trailing text nodes\n        // or if they would be leading whitespace-only text nodes:\n        //  * end > -1 indicates this is not a trailing text node\n        //  * leading node is when level is -1 and parent has length 0\n        if ((end > -1 && level + parent.length >= 0) || content !== ' ') {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n", "function attrString(attrs) {\n  const buff = []\n  for (let key in attrs) {\n    buff.push(key + '=\"' + attrs[key] + '\"')\n  }\n  if (!buff.length) {\n    return ''\n  }\n  return ' ' + buff.join(' ')\n}\n\nfunction stringify(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content\n    case 'tag':\n      buff +=\n        '<' +\n        doc.name +\n        (doc.attrs ? attrString(doc.attrs) : '') +\n        (doc.voidElement ? '/>' : '>')\n      if (doc.voidElement) {\n        return buff\n      }\n      return buff + doc.children.reduce(stringify, '') + '</' + doc.name + '>'\n    case 'comment':\n      buff += '<!--' + doc.comment + '-->'\n      return buff\n  }\n}\n\nexport default function (doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringify('', rootEl)\n  }, '')\n}\n", "import parse from './parse'\nimport stringify from './stringify'\n\nexport default {\n  parse,\n  stringify,\n}\n"],
  "mappings": "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",
  "names": ["attrRE", "stringify", "tag", "res", "type", "name", "voidElement", "attrs", "children", "tagMatch", "match", "lookup", "charAt", "length", "startsWith", "endIndex", "indexOf", "comment", "slice", "reg", "RegExp", "result", "exec", "trim", "attr", "arr", "split", "lastIndex", "substring", "tagRE", "whitespaceRE", "empty", "Object", "create", "buff", "doc", "content", "key", "push", "join", "reduce", "parse", "html", "options", "components", "current", "level", "inComponent", "end", "replace", "index", "parent", "isOpen", "isComment", "start", "nextChar", "parseTag", "test", "token", "rootEl"]
}
